设计模式六大原则

1.单一职责原则
	一个类只负责一项职责
	（一个类中多个方法实现不同的功能）
	（多个类实现不同功能）

	.降低类复杂度，一个类负责一项职责
	.提高类可读性，可维护性
	.降低变更引起的风险

2.里氏替换原则
	重写父类的方法时，通常将原本父类和子类都继承自一个更为通俗的基类，将两者的继承关系去掉，采用依赖、聚合、组合等关系代替。
	
	.降低继承风险

3.依赖倒转原则
	高层模块不依赖底层模块，二者应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象
	（抽象为基础搭建架构，制定好规范）
	（细节交给实现类完成）

	.降低类需求编写风险

4.接口隔离原则
	将接口根据不同功能拆分，使对应依赖类可以针对性的实现有作用的接口

	.降低程序复杂性

5.迪米特法则
	避免越关系调用 降低程序耦合
	
	.降低不必要依赖

6.开闭原则
	模块和函数 对外扩展开发 对修改关闭
	抽象构建框架 实现扩展细节
	当软件需要变化时，可通过扩展软件实体类实现变化，避免对已有代码进行修改。



七种设计模式

1、工厂设计模式
	
	.面向接口编程 体现面向对象的思想
	.将创建对象的工作转移到工厂类

2、策略设计模式
	管理一组同类型的算法，多个策略中选择一个生效

	多用组合 少用继承

3、单例模式
	保证一个类仅有一个实例，并提供一个访问它的全局访问点
	（全局频繁创建与销毁的类）

	.懒汉式  
	.饿汉式	 

4、命令模式
	将一系列请求命令封装起来，不直接调用真正执行者的方法。
	.为后继操作扩展

5、代理模式
	为某一个对象提供一个代理对象，有代理对象控制对原对象的引用。
	
	.中介隔离
	.开闭原则 --便于拓展功能

6、模板模式
	一个抽象类公开定义执行它的方法的方式。它的子类可以按需要重写方法实现，调用将以抽象类中定义的方式进行。

	.通用的类可以减少代码量

7、复合模式实战
	（待定）


Java反射
	Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。

1、反射机制
	Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，再通过class对象进行反编译，从而获取对象的各种信息。
	
2、内置Class实例和数组的生命周期
	在一个类编译完成之后，下一步就需要开始使用类，如果要使用一个类，肯定离不开JVM。在程序执行中JVM通过装载，链接，初始化这3个步骤完成。

	类的装载是通过类加载器完成的，加载器将.class文件的二进制文件装入JVM的方法区，并且在堆区创建描述这个类的java.lang.Class对象。用来封装数据。 但是同一个类只会被类装载器装载一次。

	链接就是把二进制数据组装为可以运行的状态。链接分为校验，准备，解析这3个阶段

	.校验一般用来确认此二进制文件是否适合当前的JVM（版本），

	.准备就是为静态成员分配内存空间。并设置默认值

	.解析指的是转换常量池中的代码作为直接引用的过程，直到所有的符号引用都可以被运行程序使用（建立完整的对应关系）

完成之后，类型也就完成了初始化，初始化之后类的对象就可以正常使用了，直到一个对象不再使用之后，将被垃圾回收。释放空间。当没有任何引用指向Class对象时就会被卸载，结束类的生命周期。

3、反射结合设计模式----动态代理
	

	.cglib

